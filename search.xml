<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redux 流程图]]></title>
    <url>%2F2019%2F04%2F14%2Fredux%2F</url>
    <content type="text"><![CDATA[梳理action经由dispatch到middleware到reducer，最后更新state以及视图的过程。]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS之博客搭建中的域名配置]]></title>
    <url>%2F2018%2F04%2F25%2Fdns-learn%2F</url>
    <content type="text"><![CDATA[探索学习域名系统，从域名解析、域名服务器、主机服务器等几个方面拨开云雾。 从输入URL开始 在浏览器客户端中输入我们购买后的域名（www.example.com），点击回车 浏览器会向此电脑的网络接入商（电信）发出域名请求，电信的DNS服务器要查询域名数据库，查找这个域名的DNS服务器，然后从中抓去记录，获取此域名指向的IP地址 电信的服务器向此IP地址所对应的服务器抓取网页内容，然后传输给浏览器 浏览器 =&gt; 电信DNS服务器 =&gt; IP =&gt; 电信服务器 =&gt; IP对应的服务器 =&gt; 浏览器 互联网的传输互联网上的每一台电脑都被分配一个IP地址，数据的传输实际上是在不同IP地址之间进行的。包括我们在家上网时使用的电脑，在连上网以后也被分配一个IP地址，这个IP地址绝大部分情况下是动态的。也就是说你关掉调制解调器，在重新打开上网，你的上网接入商会随机分配一个新的IP地址。 网站服务器（IP对应的服务器、主机服务器）网站服务器本质上也是台连上网的电脑，只不过配置上更适合作为服务器，并且放在数据中心，保持低温，低尘环境，同时有安全保卫。这些服务器使用固定IP地址连入互联网。 一个域名解析到某一台服务器上，并且把网页文件放到这台服务器上，用户的电脑才知道去哪一台服务器获取这个域名的网页信息。这是通过域名服务器来实现的。 域名服务器域名服务器是英文Domain Name Server的缩写。每一个域名都至少要有两个DNS服务器，这样如果其中一个DNS服务器出现问题，另外一个也可以返回关于这个域名的数据。DNS服务器也可以有两个以上，但所有这些DNS服务器上的DNS记录都应该是相同的。 在DNS服务器中保留有该域名的DNS记录，比如A记录，MX记录。A记录是用来指定主机名（或域名）对应的IP地址。MX记录用来解析域名的邮件服务器。在很多情况下。 A记录：地址记录，用来指定域名的IPv4地址（如：8.8.8.8），如果需要将域名指向一个IP地址，就需要添加A记录。 CNAME： 如果需要将域名指向另一个域名，再由另一个域名提供ip地址，就需要添加CNAME记录。 域名解析域名解析需要很长时间，是因为上网接入商，比如北京电信，河南电信等，为了要加速用户打开网页的速度，通常在他们的DNS服务器中缓存了很多域名的DNS记录。这样这个接入商的用户要打开某个网页时，接入商的服务器不需要去查询域名数据库，而是把自己缓存中的DNS记录直接使用，从而加快用户访问网站的速度。 缺点是上网接入商ISP的缓存会存储一段时间，只在需要的时候才更新，而更新的频率没有什么标准。有的ISP可能1小时更新一次，有的可能长达一两天才更新一次。 所以新注册的域名一般来说解析反倒比较快。因为所有的ISP都没有缓存，用户访问时ISP都是要查询域名数据库，得到最新的DNS数据。 而老域名如果更改了DNS记录，但世界各地的ISP缓存数据却并不是立即更新的。这样不同ISP下的不同用户，有的可以比较快的获取新的DNS记录，有的就要等ISP缓存的下一次更新。 说明DNS服务器和网页服务器可以是同一个提供商提供的，也可以是不同的。通常虚拟主机提供商也提供自己的DNS服务器，这样用户只要把自己的域名指向虚拟主机提供商自己的域名服务器就可以了。有的用户喜欢使用域名注册服务商提供的DNS服务器（如GoDaddy），这时候用户就要在域名注册商的DNS服务器中更改DNS记录，如A，MX记录等到虚拟主机提供商的IP地址。 基于Github Page的个人博客搭建中域名配置解析 在域名注册服务商（GoDaddy）处购买域名（www.example.com） 不使用它提供的域名服务器，使用Dnspod（国内免费DNS服务器，提供域名解析及域名记录等服务），因此需要在GoDaddy上添加Dnspod的域名服务器f1g1ns1.dnspod.net以及f1g1ns2.dnspod.net 根据github page提供的IP（192.30.252.153、192.30.252.154），在Dnspod中添加两条A记录 在Dnspod中添加一条CNAME记录，记录即为你的github page域名（yourgithubname.github.io） 在github page项目中添加CNAME文件（内容为购买的域名www.example.com） 延伸问题：为什么配置了域名解析还要配置CNAME文件呢？ 实际上，个人域名是名字，github page相当于网站空间。试想，如果不在网站空间配置CNAME，就可以成功绑定域名，那么岂不是可以给别随便一个的网站绑定上自己的域名？相同，如果只需配置github pages的CNAME，而不用域名解析，那不是也可以将自己的网站绑在人和别人的域名上？所以，域名绑定是需要“双方同意”的。 综上所述，本质上时github page提供了一个网站服务器及域名（yourgithubname.github.io），我们需要将自己购买的域名代理到github page下即可 基于自有服务器的个人博客搭建中域名配置解析同上，需要用自有服务器的IP替换github page的IP，添加A记录，以及将CNAME改为你的域名即可，相当于绕过github page提供的网站域名（yourgithubname.github.io），直接绑定自有服务器以及自有域名。 参考什么是域名解析？什么是域名服务器？]]></content>
      <categories>
        <category>DNS</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全栈前端热更新，后端服务重启，浏览器自动刷新]]></title>
    <url>%2F2017%2F03%2F20%2Fbrowser-reload%2F</url>
    <content type="text"><![CDATA[详解浏览器自刷新环境和热更新（热重载/热替换）环境搭建 第一类，文件变动 ，浏览器内容同步更新 第一种方案：浏览器刷新，BrowserSync结合gulp 第二种方案：webpack热更新 第二类，等待sass -&gt; css 、babel -&gt; es5 、 … 的编译完成后，实现浏览器内容同步 第一种方案：通过gulp的任务流，顺序执行编译以及浏览器刷新 第二种方案：webpack热更新就是在编译之后实现的，无需其它配置 第三类，文件变动 =&gt; 编译 =&gt; 重启服务器，浏览器实现内容同步需要有监听服务器重启完成后，通知浏览器实现内容同步的机制 server部分的自动刷新，会面临一个问题：自动刷新的消息通知依靠的是浏览器和服务器之间的web socket连接，但在server部分修改代码的话，一般都要重启服务器来使变更生效（比如修改接口路由routes），这就会断开web socket连接。 所以，这需要一个变通的策略：浏览器这边增加一个对web socket断开的处理，如果web socket断开，则开启一个稍长于服务器重启时间的定时任务（setTimeout），相当于等到服务器重启完毕后，再进行一次整页刷新。 方案如下： 使用supervisor/nodemon对服务器端文件监控（服务端路由，api接口等文件）， 当文件变动时，supervisor/nodemon使得服务器服务重启，并且gulp也对改文件监听改动，然后执行browser-sync的reload的延时函数，使得满足上述需求 理解要点：（以下具体参数只作为参考） 理解三个端口！！！ app应用端口为：8080 （webpack-dev提供的服务端口） 服务端端口为：3000 （express/koa/http ，node提供的服务端端口） browser-sync的端口：4000 （browser-sync配置代理proxy，代理8080端口） 理解两个启动！！！ node build/dev-server.js即npm run dev （vue-cli中提供的webpack启动命令） gulp default (gulp实现gulp-nodemon以及browser-sync的服务) webpack 只对应用（端口为8080）中的js，css等实施编译打包等，然后将打包形成的bundle文件插入app应用的index.html中，从而实现了热更新，并且在webpack-dev中设置proxy（代理），使得应用中的axios可以跨域调用服务端（3000）的接口数据，因此npm run dev =&gt; node build/dev-server.js ，此命令启动了应用的8080端口 gulp 的存在是为了实现第三类的刷新任务，browser-sync中设置proxy（8080），及代理了应用的端口，同时需要设置browser-sync的端口 （除3000之外的如4000，默认为3000），然后设置nodemon的任务，监听的服务器文件（服务端的server.js中设置了3000端口），因此gulp default命令便启动了服务端3000端口以及浏览器的4000端口（及代理了应用的8080端口） 浏览器刷新无论是热更新或者browser-sync ，都是在html文件中加入监控脚本 实践案例：vue + webpack + express + gulp。 启动文件babel语法问题 koa2 中采用了es7的async/await语法，因此采用的是babel-preset-stage-3标准，目前node最新版7.7.2可以在node中直接使用，但如果版本较低的话，得采用babel编译后执行， 第一种方法：使用node最新版，支持最新语法，直接启动文件即可 第二种方法：全局安装babel-cli，使用babel-node 启动文件，即会编译改文件并执行 第三种方法：在文件头部，引入babel-register，遇到require便会编译]]></content>
      <categories>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>Gulp</tag>
        <tag>Node.js</tag>
        <tag>nodemon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex入门到实践]]></title>
    <url>%2F2017%2F03%2F17%2Fvuex-about%2F</url>
    <content type="text"><![CDATA[vuex一探到底，vuex是为了解决什么而存在的？究竟何时需要用到它？应该如何使用？伴随这三个问题，逐步深入。 vuex解决了什么?在使用Vue开发web应用程序时，每个组件如果都有各自的状态，而且这些状态之间是有关联，这时仅靠Vue是无法合理的管理这些状态的，会导致状态和代码难以维护。 因此vuex诞生了，说简单点，它充当了所有组件的容器，并为各个组件提供了调用状态，改变状态的接口。 何时需要用到它？一般都会说，就像眼镜，你自然知道什么时候使用。 但这句话不免太过程序员语气，通俗来讲，当你的应用组件之间共用的状态出现较多时，这时vuex能够以它提供的规则，会避免你的代码和逻辑混乱，如果只有一两个共有的，可以用global event bus方案解决，本质是生成一个独立的vue实例，将共有的状态以及改变状态的方法挂载在上面，让你组件中使用的vue实例进行调用。 vuex该如何使用？上述两个问题的答案，可以看出最重要的是要理解vuex状态管理的模式，理解它提供的接口 vuex状态管理的模式： 先来看看vue状态管理模式：单向数据流，状态（state）为视图（view）的数据源，操作（actions）可以改变状态，从而改变了视图。 view -&gt; actions -&gt; state -&gt;view ... 但涉及多个组件之间的状态共享时，这个模式将难以维护，因此vuex的状态管理模式改为： vuex -&gt; actions -&gt; 提交（commit）mutations -&gt;state -&gt; view -&gt; dispatch 触发 actions -&gt;... vuex集中管理组件的状态，组件dispatch actions，然后actions才能提交改变状态的方法，状态改变了，视图也就更新了 应用中的状态不是所有都要放入vuex中，将组件之间共享的状态放入即可，像单个组件自己的状态，继续使用局部状态，避免vuex中的代码冗余 vuex提供的接口 (实例代码为vue单文件组件)​ State （状态） 状态存储了整个应用的数据，而且是唯一的，这个接口提供的是让组件获取状态数据。vue提供了vuex挂载在根节点的接口store，因此组件获取state的方式如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// ./store/index.js 存放vuex中的接口及数据的文件import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const counter = &#123; count : 0&#125;// 1. 将store挂载在根节点的vue实例上，因此所有子组件均能访问到vuex中的数据import store from './store'const app = new Vue(&#123; el: '#app', // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store, components: &#123; Counter &#125;&#125;)// 2. 在组件中获取vuex中的state&lt;template&gt; &lt;h1&gt;&#123;&#123;count&#125;&#125;&lt;/h1&gt;&lt;/template&gt;&lt;script&gt; import &#123;mapState&#125; from 'vuex' // 引入vuex /src/helper.js中的辅助函数，将多个状态生成计算属性，供组件获取状态数据state // 下面有几种写法，其实这不是重点，只是在es6,es7的语法问题 // 第一种：纯粹的调用$store对象上挂载的vuex接口数据 computed:&#123; count()&#123; return this.$store.state.count &#125; &#125; //第二种：使用vuex提供的mapState辅助函数 computed:mapState(&#123; count: state =&gt; state.count, //或者 countAlias: 'count', // 同箭头函数 // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countLocalState(state)&#123; return state.count + this.localCount &#125; &#125;) //第三种：计算属性名称与state提供的数据名称相同，直接提供字符串数组即可 computed:mapState([ 'count' // 这里不但组件模板中可以直接调用count，其它methods中可直接以this.count调用，它实质映射为store.state.count ]) //第四种写法：使用...扩展运算符，mapState返回的是对象，里面有属性方法，...可以取出参数对象中所有可遍历属性，浅拷贝至当前对象中 computed:&#123; ...mapState([ 'count' ]) &#125;&lt;/script&gt; Getters （在store中预处理state的方法） 如需要对状态事先进行筛选，可以将此操作封装为函数方法，赋予getters，这样做的好处是所有组件共用此函数，不必在每个组件中重复写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// ./store/index.js store 文件中const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) // [&#123; id: 1, text: '...', done: true &#125;] &#125;, // 可以接受其他getters方法作为第二参数 doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length // 1 &#125; &#125;&#125;)// 在组件中使用vuex中的getters&lt;template&gt; &lt;h1&gt;&#123;&#123;count&#125;&#125;&lt;/h1&gt;&lt;/template&gt;&lt;script&gt; import &#123;mapGetters&#125; from 'vuex' // 引入vuex /src/helper.js中的辅助函数，将多个状态生成计算属性 // 第一种：纯粹的调用$store对象上挂载的vuex接口数据 computed:&#123; doneTodos () &#123; return this.$store.getters.doneTodos &#125; &#125; //第二种：计算属性名称与getters提供的数据名称相同，直接提供字符串数组即可 使用...扩展运算符，mapGetters返回的是对象，里面有属性方法，...可以取出参数对象中所有可遍历属性，浅拷贝至当前对象中 computed:&#123; ...mapGetters([ 'doneTodos' ]) &#125; // 第三种：如果在组件中想用其他属性名替代getters提供的属性名，使用对象形式即可 computed:&#123; ...mapGetters(&#123; mydoneTodos: 'doneTodos' &#125;) &#125;&lt;/script&gt; Mutations （更改vuex的store中的state唯一的办法就是提交mutations） 每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。 mutation 必须是同步函数，分发在组件methods 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//使用常量替代 Mutation 事件类型// mutation-types.jsexport const SOME_MUTATION = 'SOME_MUTATION'// ./store/index.js 文件中import Vuex from 'vuex'import &#123; SOME_MUTATION &#125; from './mutation-types'const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations:&#123; increment(state)&#123; // 改变状态 state.count++; &#125;, // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 [SOME_MUTATION] (state) &#123; // mutate state &#125; &#125; //可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload） mutations:&#123; increment(state,payload)&#123; // 改变状态 state.count += payload.num; &#125; &#125;&#125;)// 在组件中使用vuex中的mutations&lt;template&gt; &lt;h1&gt;&#123;&#123;count&#125;&#125;&lt;/h1&gt;&lt;/template&gt;&lt;script&gt; import &#123;mapMutations&#125; from 'vuex' // 引入vuex /src/helper.js中的辅助函数，将多个状态生成计算属性 // 第一种：纯粹的调用$store对象上挂载的vuex接口数据 methods:&#123; increment () &#123; return this.$store.commit('increment') &#125; &#125; //第二种：计算属性名称与mutations提供的数据名称相同，直接提供字符串数组即可 使用...扩展运算符，mapMutations返回的是对象，里面有属性方法，...可以取出参数对象中所有可遍历属性，浅拷贝至当前对象中 methods:&#123; ...mapMutations([ 'increment' // 映射 this.increment() 为 this.$store.commit('increment') ]), &#125; // 第三种：如果在组件中想用其他属性名替代mutations提供的属性名，使用对象形式即可 methods:&#123; ...mapMutations(&#123; myincrement: 'increment' &#125;) &#125;&lt;/script&gt; Actions （提供异步提交mutations的接口） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// ./store/index.js 文件中import Vuex from 'vuex'const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations:&#123; increment(state)&#123; // 改变状态 state.count++; &#125; &#125;, actions:&#123; //Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象， //因此你可以调用 context.commit 提交一个 mutation， //或者通过 context.state 和 context.getters 来获取 state 和 getters。 increment (context) &#123; context.commit('increment') //这里提交的就是mutations &#125; &#125; // 或者通过参数结构的语法这样写 actions: &#123; increment (&#123; commit &#125;) &#123; commit('increment') &#125;, // 异步提交mutations incrementAsync (&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit('increment') &#125;, 1000) &#125;, // 可以使用promise或者async / await 组合使用actions actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('someMutation') resolve() &#125;, 1000) &#125;) &#125;, actionB (&#123; dispatch, commit &#125;) &#123; return dispatch('actionA').then(() =&gt; &#123; commit('someOtherMutation') &#125;) &#125; &#125;&#125;)// 组件中使用actions&lt;template&gt; &lt;h1&gt;&#123;&#123;count&#125;&#125;&lt;/h1&gt;&lt;/template&gt;&lt;script&gt; import &#123;mapActions&#125; from 'vuex' // 引入vuex /src/helper.js中的辅助函数，将多个状态生成计算属性 // 第一种：纯粹的调用$store对象上挂载的vuex接口数据 methods:&#123; increment () &#123; return this.$store.dispatch('increment') &#125; &#125; //第二种：计算属性名称与state提供的数据名称相同，直接提供字符串数组即可 使用...扩展运算符，mapActions返回的是对象，里面有属性方法，...可以取出参数对象中所有可遍历属性，浅拷贝至当前对象中 methods:&#123; ...mapActions([ 'increment' // 映射 this.increment() 为 this.$store.dispatch('increment') ]), &#125; // 第三种：如果在组件中想用其他属性名替代actions提供的属性名，使用对象形式即可 methods:&#123; ...mapActions(&#123; myincrement: 'increment' &#125;) &#125;&lt;/script&gt; Modules （将store分为不同的模块，更好的管理状态） 每一个module中都有各自的state,getters,mutations,actions. 12345678910111213141516171819const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;) 模块内部的 action、mutation、和 getter 注册在全局命名空间——这样保证了多个模块能够响应同一 mutation 或 action。 举例解释：即上述的A和B模块中声明的mutations可以被actions.js根（全局）文件中调用 ​]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql]]></title>
    <url>%2F2016%2F12%2F04%2FMysql%2F</url>
    <content type="text"><![CDATA[记录了MySQL常用命令，以便不时之需。 常用命令及设置 1234567// ~/.zshrc#mysql ================================ alias mysql='/usr/local/mysql/bin/mysql' alias mysqladmin='/usr/local/mysql/bin/mysqladmin' alias start='sudo /usr/local/mysql/support-files/mysql.server start' alias stop='sudo /usr/local/mysql/support-files/mysql.server stop' alias restart='sudo /usr/local/mysql/support-files/mysql.server restart' show databases; 显示所有数据库 create dbname 创建数据库 use &lt;数据库名&gt; 打开某数据库 create tbname(column_name data_type,...) 创建数据表 show create tbname; 查看创建的数据表输入的命令 select database() 选择数据表 show tables 显示数据表 show columns from tbname 显示数据表结构 insert tbname(...) values(...) 插入数据 select ... from tbname 显示数据表中的所有记录 show indexes from tbname\G 显示数据表中的索引(树状显示) delete from tbname where... 删除记录 修改数据表 alter table tbname add (column_name data_type) after/before (column_name) 添加单列数据 alter table tbname drop column_name1 , drop column_name2… 删除表中列 alter table tb_name modify ...first/before 修改列定义（数据类型及位置） 特殊字符及各项约束 signed / unsigned 有无符号 （+ /-） null / not null 空 / 非空 auto_increment 唯一自增，必须与主键配合使用 primary key 主键约束，一张数据表只能存在一个主键，保证记录唯一性，会自动创建索引 unique key唯一约束，一张数据表可以存在多个 default 默认值设定，插入数据如果为空，则默认设定默认值 foreign key 外键约束，字表设置外键时，外键列与父表参照列数据属性需要一致，存储引擎只能为InnoDB，外键列和参照列必须创建索引，外键的pid对应着父表的参照列中的id 1234567891011121314// 父表 id 参照列create table provinces( id samllint unsigned primary key auto_increment, pname varchar(20) not null);//字表 pid 外键列create table users( id samllint unsigned primary key auto_increment, username varchar(20) not null, // 保证数据类型与参照列一致 pid smallint unsigned, // foreign key (pid) references provinces (id) on delete cascade) cascade 从父表中删除或更新且自动删除或更新子表外键中对应的行 set null 从父表中删除或更新且自动设置子表外键为null restrict 拒绝对父表的更新或删除操作 not action 与restrict相同 记录操作 插入记录 insert into tb_name]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2016%2F11%2F16%2Fgit%2F</url>
    <content type="text"><![CDATA[Git常用命令，以备不时之需。 git 常用命令 初始化Git仓库：git init 将文件（新添加的或者修改的）添加进暂存区：git add file 查看被修改的文件状态：git status 将暂存区的文件提交到最终的分支仓库中：git commit -m &quot;修改内容&quot; 查看文件的不同之处：git diff 查看提交的历史纪录：git log 查看所有的历史纪录：git reflog 返回历史版本（回退）：git reset 返回文件修改之前的状态：git checkout - -file 建立与Github的远程仓库连接：git remote add origin git@github.com:Selvin11/.. 关联本地和远程的仓库内容：git push -u origin master clone远程仓库内容到本地：git clone git@github.com:Selvin11/.. 创建新的分支并切换到该分支：git checkout -b gh-pages这其实是两个步骤，首先创建分支：git branch gh-pages,然后是进入该分支：git checkout gh-pages 合并新分支到master分支上：git merge gh-pages,默认Fast forward模式,但此模式会将分支信息丢掉，一般使用git merge --no-ff -m &quot;merge with no-ff&quot; gh-pages,表示禁用Fast forward模式 删除分支：git branch -d gh-pages 解决冲突，当不同分支提交相同文件时，但是内容不同，就会造成commit提交失败，此时需要手动解决，将两处内容重新整合成一样的，然后add,commit,用git log --graph命令可以看到分支合并图。 Bug分支，面对突如其来的Bug，不要慌，我们可以暂时隐藏工作区，创建Bug分支，解决之后，合并后并删除，接下来将隐藏的现实出来就行了：git stash隐藏，git stash list可以查看隐藏内容列表，然后采用git stash pop来恢复隐藏的工作区，恢复的同时也将stash删除了。 对于已经commit的分支，但未push，我们需要删除它，怎么办：git branch -D filename,采用强制删除分支命令 查看远程库内容：git remote,详细内容git remote -v,推送分支内容：git push origin &lt;name&gt;,origin是当初建立连接时为远程库起的名字，抓取分支,从Github上clone下来的项目只有master分支，其他分支需要抓取：git checkout -b gh-pages origin/gh-pages 多人协作： 查看远程库信息，使用git remote -v；本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 zsh mkdir filename 创建目录 touch index.js 创建文件 rm index.js 删除文件 rm -r filename 删除目录]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native 开发环境搭建]]></title>
    <url>%2F2016%2F11%2F10%2Freact-native%2F</url>
    <content type="text"><![CDATA[分别实践了Windows/OSX上的Android运行环境，以及OSX上的IOS运行环境，记录下了其中的坑洼。 Windows 搭建Android运行环境 首先安装Java，直接在官方网站下载最新版本即可（1.8以上） 接下来，安装Python2、Node.js 使用npm全局安装react native cli 和 yarn(增加包管理下载速度) 下载Android Studio（安卓运行sdk以及安卓虚拟机），根据教程将所有必须项安装 点击SDK Manager中的Launch Standalone SDK Manager，找到ADV Manager，打开一个android虚拟机，没有的话就创建一个即可 react-native run-android 执行react-native run-android命令后出现的问题 post占用，使用命令行查找使用该端口的进程，并杀掉即可 安卓虚拟机创建，点击Android SDK，点击Launch Standalone SDK Manager，进入AVD Tools进行创建 下载Gradle过程出现中断，根据下载路径，用浏览器打开进行离线下载安装，下载之后放置与/users/username/.gradle/wrapper/dists/目录下 出现Java文件未能执行的问题，配置JAVA_HOME环境变量 OSX 配置 Android环境 基本同上，遇到下载Gradle中断问题，离线下载至~/.gradle/wrapper/dists 分析各项安装包的作用 Android Studio（包含了运行和测试React Native应用所需的Android SDK和模拟器） JDK(JAVA环境，Android Studio运行必备) Android SDK(android运行必备,提供android各版本支持)Google APIs、Android SDK Platform 23` Intel x86 Atom System Image、Intel x86 Atom_64 System Image以及Google APIs Intel x86 Atom_64 System Image`以上几个是虚拟机内置环境 Android SDK Build-Tools 23.0.1（必须是这个版本）与Android SDK Platform 23对应 因此方案二：使用性能更好的Genymotion模拟器，放弃Android Studio自带模拟器 注册Genymotion账号，下载Genymotion和VirtualBox，下载一个版本的机型即可，下载中断问题，同样找到下载路径，进行离线下载，放置于路径/Users/username/.Genymobile/Genymotion/ova/即~/.Genymobile/Genymotion/ova/(Windows/OSX操作步骤一直) 因此关于Android Studio下载的必须项目即Google APIs、Android SDK Platform 23、Android SDK Build-Tools 23.0.1这三个即可，而且在安装界面也可以不勾选内置模拟器Android Virtual Device 方案二同比方案一安装完全减少10G作用的容量=。= 环境搭建至此。]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除浮动]]></title>
    <url>%2F2016%2F10%2F17%2Fclearfix%2F</url>
    <content type="text"><![CDATA[支持IE6及以上的浏览器，全浏览器通用的clearfix方案，并梳理了一下BFC。 clearfix 12345678910111213// 引入了zoom以支持IE6/7// 同时加入:before以解决现代浏览器上边距折叠的问题.clearfix:before,.clearfix:after &#123; display: table; content: " ";&#125;.clearfix:after &#123; clear: both;&#125;.clearfix&#123; *zoom: 1;&#125; BFC BFC就是页面上的一个独立的容器，容器内的子元素不会影响到外面的元素，外面的元素也不会影响到容器内的子元素。 盒子垂直方向的距离由margin决定，属于同一个BFC的相邻盒子的上下margin会发生折叠，分别触发两个元素的BFC，就可以解决垂直边距折叠的问题 BFC可以包含浮动，通常用来解决浮动父元素高度坍塌的问题。 BFC的触发方式： float 为 left | right overflow 为 hidden | auto | scorll display 为 table-cell | table-caption | inline-block | flex | inline-flex position 为 absolute | fixed 通常为父级元素添加overflow:hidden;兼容IE]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>BFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取input上传图片，实现裁剪功能]]></title>
    <url>%2F2016%2F10%2F10%2Ffile-reader%2F</url>
    <content type="text"><![CDATA[使用FileReader对象实现web异步读取计算机上的文件，同时可以使用file对象来指定的处理的文件或数据 readAsDataURL() 开始读取指定的File对象中的内容,result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容. 123456789101112131415161718192021222324&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="file" type="file"&gt; &lt;img src="" id="image"&gt;&lt;/body&gt;&lt;script type="text/javascript" src="jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;$('#file').on('change', function() &#123; var reader = new FileReader(); reader.onload = function(e) &#123; $('#image').attr('src', e.target.result); &#125; //readAsDataURL 将选取的文件以data:形式的数据存储在e.target.result中 //result属性的返回值是任意类型，返回本次事件触发执行的上一个事件处理函数的返回值 reader.readAsDataURL(this.files[0]);&#125;)&lt;/script&gt;&lt;/html&gt; 123multiple属性可以让用户能选择多个文件&lt;input id="myfiles" multiple type="file"&gt; 图片裁剪并上传 插件cropbox , 将canvas得到的base64格式图片传至后端，进行png格式转化，并存入文件目录]]></content>
      <categories>
        <category>常见功能</category>
      </categories>
      <tags>
        <tag>FileReader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[National Day]]></title>
    <url>%2F2016%2F10%2F01%2Fnational-day%2F</url>
    <content type="text"><![CDATA[国庆宅记Vue.js 2.0 正式公测！]]></content>
      <tags>
        <tag>Vue.js 2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F09%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[关于博客的升级在初学前端之际，采用Jekyll创建了人生的第一个博客，但当时技术有限，学习任务紧，没有很好的进行设计和性能优化，如今也开始了实习阶段，想将自己的点滴成长记录在于一个能够看得过去的博客之上，因此就有了此次博客的升级。 前端学习路漫漫其修远兮，不巧，在今天微信小程序也炸开了锅，在前端前景如此看好的环境下，不由得促使我更加认真努力的踏上学习之路，再次与内心世界的我一起约定，每天一进步！]]></content>
  </entry>
  <entry>
    <title><![CDATA[Node.js + express + jade开发指南实例]]></title>
    <url>%2F2016%2F06%2F16%2Fnodejs-blog%2F</url>
    <content type="text"><![CDATA[Node.js 开发指南实例——Microblog app.js—–express详解及问题总结 自有模块&amp;&amp;引入模块 Express 4.x 目前只有express.static一个唯一的中间件，用于托管内部静态资源，express.static(path.join(__dirname, &#39;public&#39;))，此为常见用法，__dirname即为当前目录名。 http/fs/path均为Node.js的原生模块 问题1 =&gt; flash()方法弃用 Express 4.x 已经不支持flash()方法，需要引入模块require(&#39;connect-flash&#39;)，此模块就是提供原有的flash()方法，但在用之前需要app.use(flash())，这样相当于激活该方法，下面来讲讲flash()是什么，通过NPM和其对应的英文文档描述，主要起到处于客户端和服务端的桥梁作用，能够缓存服务器通过模板引擎传递给客户端的数据，并且是一次性的，属于用即弃的性质，因此简化的会话操作。 问题2 =&gt; mongodb相关模块的使用 123var session = require('express-session');var settings = require('./settings');var MongoStore = require('connect-mongo')(session); 这些都是相关的模块引入，主要是session的设置，这里引出关于session和cookie的关联问题，（cookie和session都是为了记录用户与浏览器之间以及浏览器和服务器之间的会话记录的，cookie存在于浏览器客户端中，session则存在服务器中，相比的话session的安全级别更高）。​ 引入模块之后，需要设置session，书中提供的方法已经不适用了，解决如下： 注释掉db,host,port等一个个的设置，直接写上真正的url地址即可 12345678910111213app.use(session(&#123; resave:false,//添加这行 saveUninitialized: true,//添加这行 secret: settings.cookieSecret, key: settings.db,//cookie name cookie: &#123;maxAge: 1000 * 60 * 60 * 24 * 30&#125;,//30 days store: new MongoStore(&#123; //现在需要直接写上url地址，其余的都注释掉就行 // db: settings.db, // host: settings.host url:'mongodb://localhost/nodeweb' &#125;)&#125;)); 问题3 =&gt; view视图交互代码弃用 关于视图交互，即MVC中的”V”，主要用作用是为用户提供更好的视图体验以及缓存数据信息，打通数据库与浏览器之间的管理，比如，用户在登录时，重名，密码错误等问题，这些都可以通过session先将信息传递给response服务器返回信息，然后通过本地的flash()方法，将服务器返回的信息，通过模板引擎二次加工，呈现给用户，提升用户体验。 解决代码如下，替换原有的即可： 123456789app.use(function(req,res,next)&#123; res.locals.user = req.session.user; var err = req.flash('error'); var success = req.flash('success'); res.locals.error = err.length ? err : null; res.locals.success = success.length ? success : null; //next()函数相当于跳过继续，实质是将视图路由控制权再交还给其他路由视图next();&#125;); 问题4 =&gt; 路由 这个其实是理解的关键，express本身就是路由 + 中间件（相当于第三方模块）构成的，但是其控制路由的方式方法很多，就有种jquery中ajax()一整套方法以及其各种分支方法的组合，先从书中案列讲起，书中一开始提及的就是app，即var app = express();，app相当于express的实例，从官方文档可以了解，挂载了许多方法，其中就有一个app.route()，而且express本身就有一个Router模块，（区别是什么：本身的模块也可以控制设置路由，但是是挂载在express.Router()下的，无法使用express()下的方法，所以一般是在express.Router()下配置路由，再导出模块，使用express()的use方法调用）这个方法下面可以链式调用get/post…一系列方法。 源码解析： 12345//首先是app.config()配置var routes = require('./routes/index');app.use(routes);//这个配置就是路由调用方法的关键，routes是存放在routes文件夹下面的index.js模块中的//于是我们可以将路由控制先写在index.js中，然后让app.js调用 但是，以上代码已经不适用，解决方案如下，还是讲路由控制的代码挂载在index.js模块中。代码如下： 12345678910111213141516171819var express = require('express');var router = express.Router();var crypto = require('crypto');var User = require('../models/user.js');var Post = require("../models/post.js");// 定义网站的各项路由，然后输出此模块/* GET home page. */router.get('/', function(req, res, next) &#123; // 通过Post的get方法中的回调函数获取posts数据 Post.get(null,function (err,posts) &#123; if (err) &#123; posts=[]; &#125; res.render('index',&#123; title: '首页', posts: posts &#125;) &#125;)&#125;); 这只是其中主页面的路由设置信息，主要就是用express.Router()来配置路由，然后导出路由模块，由express()来写入session信息，从而使得数据库与浏览器客户端建立连接，这样也使得数据和路由主配置较为干净，即app.js较为清晰，能一眼看到引入的模块，以及数据库信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384var express = require('express');var path = require('path');// 数据库及session相关模块引入var session = require('express-session');var settings = require('./settings');var MongoStore = require('connect-mongo')(session);var User = require('./models/user.js');var Post = require('./models/post.js');var favicon = require('serve-favicon');var logger = require('morgan');var cookieParser = require('cookie-parser');var bodyParser = require('body-parser');var crypto = require('crypto');var flash = require('connect-flash');var routes = require('./routes/index');var app = express();// 添加flash()方法==================================要点1app.use(flash());// view engine setupapp.set('views', path.join(__dirname, 'views'));app.set('view engine', 'jade');// uncomment after placing your favicon in /public//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));app.use(logger('dev'));app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(cookieParser());app.use(express.static(path.join(__dirname, 'public')));// mongodb connectapp.use(session(&#123; // ==============================================要点2 resave:false,//添加这行 saveUninitialized: true,//添加这行 secret: settings.cookieSecret, key: settings.db,//cookie name cookie: &#123;maxAge: 1000 * 60 * 60 * 24 * 30&#125;,//30 days store: new MongoStore(&#123; // db: settings.db, // host: settings.host // =============================================要点3 url:'mongodb://localhost/nodeweb' &#125;)&#125;));// view 视图交互，实现不同登录状态下呈现不同内容// 设置请求头user信息，为index.jade做铺垫// ==================================================要点4app.use(function(req,res,next)&#123; res.locals.user = req.session.user; var err = req.flash('error'); var success = req.flash('success'); res.locals.error = err.length ? err : null; res.locals.success = success.length ? success : null; next();&#125;);// 路由输出app.use('/',routes);// catch 404 and forward to error handlerapp.use(function(req, res, next) &#123; var err = new Error('Not Found'); err.status = 404; next(err);&#125;);// error handlers// development error handler// will print stacktraceif (app.get('env') === 'development') &#123; app.use(function(err, req, res, next) &#123; res.status(err.status || 500); res.render('error', &#123; message: err.message, error: err &#125;); &#125;);&#125;// production error handler// no stacktraces leaked to userapp.use(function(err, req, res, next) &#123; res.status(err.status || 500); res.render('error', &#123; message: err.message, error: &#123;&#125; &#125;);&#125;);module.exports = app; Jade 通过我们建立的post/user/..等模型中的回调函数将模板中的数据信息写入数据库，以及通过回调函数拿到数据库中的信息传递给模板，并让浏览器解析产生页面。 主要是模板中的继承extend/包含include/自定义代码块blcok…等的使用。 由于书中采用的是ejs模板，由于和后端代码书写太相像，使用过便放弃了，使得html代码看着太奇怪，jade的简写其实很好，就是有时候没注意空格和缩进=。= 贴一个将文中一个ejs模板替换的jade模板，以供参考： 12345678.roweach item in posts .col-md-4 h2 a(href='/u/'+item.user)= item.user != '&lt;samll&gt;'+' 说'+'&lt;/samll&gt;' p!= '&lt;samll&gt;'+item.time+'&lt;/samll&gt;' p= item.post 以上是从Node.js开发指南中的总结以及问题处理，感谢作者，感谢百度及谷歌，问题不可怕，先自己多想，多看官方文档，实在不行，还有N多大神在网上写有解答，之前也用node仿照慕课视频上做了一个电影网站，但感觉不系统，这次便重新系统了巩固一下，其实Node.js很够学，只是会使用require几个模块是没什么大用的，主要是要学习其机制，模块，MVC，模板这些在早些年，在其它语言中都有过，只是将业务逻辑，视图，行为分离，使得人能有一个大局观，然后在各个层中专一，逐层击破罢了，如果人能够轻松实现多线程，也就没有单线程非阻塞这一说了~ 鄙人小白一个，从心喜欢前端，仍在不断深入前端领域以及强化基础，从未指望一蹴而就，只想深入几十载，再回首。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
</search>
